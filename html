<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load Balancer Pro - Interactive Presentation</title>
    <style>
        :root {
            --bg-color: #0b0c10;
            --panel-bg: #1f2833;
            --text-color: #66fcf1;
            --accent-color: #45a29e;
            --danger-color: #ff0055;
            --success-color: #00ff66;
            --warning-color: #ffcc00;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            scroll-behavior: smooth;
        }

        /* Nav Bar */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background-color: rgba(31, 40, 51, 0.95);
            border-bottom: 2px solid var(--accent-color);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            padding: 15px 30px;
            box-sizing: border-box;
        }

        nav h1 {
            margin: 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-links a {
            color: var(--text-color);
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s;
        }

        .nav-links a:hover {
            color: var(--success-color);
            text-shadow: 0 0 5px var(--success-color);
        }

        /* Sections */
        section {
            padding: 80px 40px;
            min-height: 80vh;
            border-bottom: 1px solid #333;
            box-sizing: border-box;
        }

        h2 {
            font-size: 2.5rem;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px var(--accent-color);
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #c5c6c7;
            max-width: 800px;
        }

        /* Simulation Section Specifics */
        #visualization {
            height: 100vh;
            padding-top: 80px;
            display: flex;
            flex-direction: column;
        }

        .sim-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1d26 0%, #0b0c10 100%);
            border: 1px solid var(--accent-color);
            margin-top: 20px;
            border-radius: 5px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 5px;
            flex-wrap: wrap;
        }

        button,
        select {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            padding: 8px 15px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            text-transform: uppercase;
        }

        button:hover,
        select:hover {
            background: var(--accent-color);
            color: var(--bg-color);
            box-shadow: 0 0 10px var(--accent-color);
        }

        .btn-danger {
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .btn-danger:hover {
            background: var(--danger-color);
            color: white;
            box-shadow: 0 0 10px var(--danger-color);
        }

        /* Integration Section - Terminal Look */
        .terminal-window {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 20px;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .code-block {
            color: #ccc;
            white-space: pre;
        }

        /* Comparison Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 40px;
        }

        th,
        td {
            border: 1px solid var(--accent-color);
            padding: 15px;
            text-align: left;
        }

        th {
            background-color: rgba(69, 162, 158, 0.2);
            color: var(--text-color);
            font-size: 1.2rem;
        }

        /* Significance Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .metric-card {
            background: var(--panel-bg);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--accent-color);
            transition: transform 0.3s;
        }

        .metric-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(69, 162, 158, 0.3);
        }

        .metric-value {
            font-size: 3rem;
            font-weight: bold;
            color: var(--success-color);
            margin: 10px 0;
        }

        /* Existing Styles for Sim Overlay */
        .system-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--accent-color);
            padding: 10px 20px;
            border-radius: 5px;
            pointer-events: none;
            text-align: center;
            display: flex;
            gap: 20px;
            white-space: nowrap;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success-color);
            margin-right: 5px;
            box-shadow: 0 0 5px var(--success-color);
        }

        #alert-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 100;
        }

        .alert-success {
            background: rgba(0, 255, 102, 0.2);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .alert-warning {
            background: rgba(255, 204, 0, 0.2);
            border: 1px solid var(--warning-color);
            color: var(--warning-color);
        }

        .alert-danger {
            background: rgba(255, 0, 85, 0.2);
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
        }

        .stats-bar {
            background-color: rgba(31, 40, 51, 0.8);
            padding: 10px 20px;
            display: flex;
            justify-content: space-around;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .latency-high {
            color: var(--danger-color);
        }

        .latency-low {
            color: var(--success-color);
        }
    </style>
</head>

<body>

    <nav>
        <h1>Load Balancer Pro</h1>
        <div class="nav-links">
            <a href="#visualization">Vis</a>
            <a href="#integration">Integration</a>
            <a href="#comparison">Comparison</a>
            <a href="#significance">Significance</a>
        </div>
    </nav>

    <!-- SECTION 1: VISUALIZATION (THE SIM) -->
    <section id="visualization">
        <div class="controls">
            <select id="algo-select">
                <option value="round-robin">Round Robin</option>
                <option value="no-lb">No Load Balancer</option>
            </select>
            <label style="font-size: 0.8rem; margin-left: 10px;">
                <input type="checkbox" id="auto-traffic" checked> Auto Traffic
            </label>
            <button onclick="sim.addClient()">+1 Client</button>
            <button onclick="sim.ddos(50)" class="btn-danger">DDOS</button>
            <button onclick="sim.toggleServer(0)" id="btn-srv-0" class="btn-danger">Kill Srv A</button>
            <button onclick="sim.toggleServer(1)" id="btn-srv-1" class="btn-danger">Kill Srv B</button>
            <button onclick="sim.toggleServer(2)" id="btn-srv-2" class="btn-danger">Kill Srv C</button>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <span>Algorithm</span>
                <span id="stat-algo" class="stat-value">Round Robin</span>
            </div>
            <div class="stat-item">
                <span>Avg Latency</span>
                <span id="stat-latency" class="stat-value latency-low">20ms</span>
            </div>
            <div class="stat-item">
                <span>Active Req</span>
                <span id="stat-reqs" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span>Server Health</span>
                <span id="stat-health" class="stat-value" style="color: var(--success-color)">100%</span>
            </div>
        </div>

        <div class="sim-container">
            <canvas id="simCanvas"></canvas>
            <div id="alert-box" class="alert-success">SYSTEM NORMAL</div>
            <div class="system-info">
                <p><span class="status-indicator" id="sys-indicator"></span>STATUS: <span
                        id="sys-status-text">ONLINE</span></p>
            </div>
        </div>
    </section>

    <!-- SECTION 2: INTEGRATION -->
    <section id="integration">
        <h2>Integration & Systems</h2>
        <p>
            Load balancing is a critical component in modern system design, integrating directly with Cloud
            Infrastructure (AWS, GCP) and Operating Systems.
            It acts as the "Traffic Cop" sitting between the public internet and private server clusters.
        </p>

        <div class="terminal-window">
            <div class="code-block">
                root@aws-elb:~# cat /etc/nginx/nginx.conf
                upstream backend_servers {
                # Integration with Server Farm
                server 10.0.0.1:8080 weight=1; # Server A
                server 10.0.0.2:8080 weight=1; # Server B
                server 10.0.0.3:8080 weight=1; # Server C

                # OS Health Checks
                check interval=3000 rise=2 fall=5 timeout=1000;
                }

                server {
                listen 80;
                location / {
                proxy_pass http://backend_servers;
                }
                }
            </div>
            <br>
            <div>> AWS CloudWatch Stream: <span style="color: var(--success-color)">Healthy</span></div>
            <div>> Mapping Strategy: <span style="color: var(--accent-color)">Least Connections</span></div>
        </div>
    </section>

    <!-- SECTION 3: COMPARISON -->
    <section id="comparison">
        <h2>Algorithm Comparison</h2>
        <p>
            Choosing the right mapping technique is essential for performance. Here is how "No Load Balancer" compares
            to standard "Round Robin".
        </p>

        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>No Load Balancer (Direct)</th>
                    <th>Round Robin (LB)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Distribution</strong></td>
                    <td>100% Traffic to Server A</td>
                    <td>33% Traffic to A, B, C</td>
                </tr>
                <tr>
                    <td><strong>Failure Point</strong></td>
                    <td><span style="color: var(--danger-color)">Single Point of Failure</span></td>
                    <td><span style="color: var(--success-color)">Fault Tolerant (Redundant)</span></td>
                </tr>
                <tr>
                    <td><strong>Latency (Heavy Load)</strong></td>
                    <td>High (>500ms) due to queueing</td>
                    <td>Low (~20ms) via parallel processing</td>
                </tr>
                <tr>
                    <td><strong>Scalability</strong></td>
                    <td>Vertical Only (Expensive)</td>
                    <td>Horizontal (Add more nodes)</td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- SECTION 3.5: LATENCY GRAPH -->
    <section id="latency-graph-section">
        <h2>Latency Analysis</h2>
        <p>Visualizing the stability difference between Load Balanced vs Direct Traffic over time.</p>
        <div style="background: #111; border: 1px solid #45a29e; padding: 20px; border-radius: 5px; margin-top: 20px;">
            <canvas id="latencyCanvas" height="300" style="width: 100%; height: 300px;"></canvas>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px;">
                <div style="color: #00ff66;">‚óè Round Robin (Stable)</div>
                <div style="color: #ff0055;">‚óè No Load Balancer (Volatile)</div>
            </div>
        </div>
    </section>

    <!-- SECTION 4: SIGNIFICANCE -->
    <section id="significance">
        <h2>Significance & Impact</h2>
        <p>
            The project demonstrates how proper load balancing reduces computation time from potentially infinite
            (crashes) to mere milliseconds.
        </p>

        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Computation Time</h3>
                <div class="metric-value">25x</div>
                <p>Faster processing using parallel server distribution.</p>
            </div>
            <div class="metric-card">
                <h3>Uptime Reliability</h3>
                <div class="metric-value">99.99%</div>
                <p>vs 85.00% for single-server architectures.</p>
            </div>
            <div class="metric-card">
                <h3>Cost Efficiency</h3>
                <div class="metric-value">40%</div>
                <p>Reduction in wasted idle resources.</p>
            </div>
        </div>
    </section>

    <script>
        class Simulation {
            constructor() {
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.packets = [];
                this.servers = [
                    { id: 'A', x: 0, y: 0, active: true, connections: 0, load: 0, maxLoad: 5, color: '#45a29e' },
                    { id: 'B', x: 0, y: 0, active: true, connections: 0, load: 0, maxLoad: 5, color: '#45a29e' },
                    { id: 'C', x: 0, y: 0, active: true, connections: 0, load: 0, maxLoad: 5, color: '#45a29e' }
                ];
                // Offset LB to center of its container
                this.lb = { x: 0, y: 0, width: 60, height: 60 };

                this.algorithm = 'round-robin';
                this.rrIndex = 0;
                this.totalLatency = 0;
                this.latencySampleCount = 0;
                this.processedCount = 0;
                this.activeServers = 3;

                this.alertBox = document.getElementById('alert-box');
                this.autoTrafficEnabled = true;

                // Initial resize
                this.resize();
                window.addEventListener('resize', () => this.resize());

                document.getElementById('algo-select').addEventListener('change', (e) => this.setAlgorithm(e.target.value));
                document.getElementById('auto-traffic').addEventListener('change', (e) => {
                    this.autoTrafficEnabled = e.target.checked;
                });

                // Auto Traffic Loop
                setInterval(() => {
                    if (this.autoTrafficEnabled) {
                        this.addClient();
                    }
                }, 1500);

                this.loop();
            }

            resize() {
                // Must resize to parent container, not window
                const container = this.canvas.parentElement;
                this.canvas.width = container.offsetWidth;
                this.canvas.height = container.offsetHeight;

                // Reposition elements
                const w = this.canvas.width;
                const h = this.canvas.height;

                this.lb.x = w / 2 - 30;
                this.lb.y = h / 2 - 30;

                const serverSpacing = 120; // Tighter spacing for smaller height
                const startY = h / 2 - serverSpacing;

                this.servers.forEach((s, i) => {
                    s.x = w - 120;
                    s.y = startY + (i * serverSpacing) - 30;
                });
            }

            setAlgorithm(algo) {
                this.algorithm = algo;
                document.getElementById('stat-algo').innerText = algo.replace('-', ' ').toUpperCase();

                if (algo !== 'no-lb' && !this.servers[0].active) {
                    this.servers[0].active = true;
                    this.servers[0].color = '#45a29e';
                }
            }

            addClient() {
                const startY = (Math.random() * this.canvas.height * 0.6) + (this.canvas.height * 0.2);
                this.packets.push({
                    x: 50,
                    y: startY,
                    targetX: this.lb.x,
                    targetY: this.lb.y + 30, // Center of LB
                    speed: 5 + Math.random() * 2,
                    state: 'toLB',
                    assignedServer: null,
                    color: '#fff',
                    birth: Date.now()
                });
            }

            ddos(count) {
                let i = 0;
                const interval = setInterval(() => {
                    this.addClient();
                    i++;
                    if (i >= count) clearInterval(interval);
                }, 30);
            }

            toggleServer(index) {
                const s = this.servers[index];
                s.active = !s.active;
                const btn = document.getElementById(`btn-srv-${index}`);

                if (!s.active) {
                    s.color = '#333';
                    btn.innerText = `Revive ${s.id}`;
                    btn.className = 'btn-success'; // If success class exists or just remove danger
                    btn.style.borderColor = '#00ff66';
                    btn.style.color = '#00ff66';
                    this.showAlert(`SERVER ${s.id} FAILURE DETECTED`, "danger");
                } else {
                    s.color = '#45a29e';
                    btn.innerText = `Kill Srv ${s.id}`;
                    btn.className = 'btn-danger';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    this.showAlert(`SERVER ${s.id} RESTORED`, "success");
                    s.connections = 0; // Reset load for visual clarity
                }
            }

            getTargetServer() {
                if (this.algorithm === 'no-lb') {
                    return this.servers[0];
                }

                if (this.algorithm === 'round-robin') {
                    let attempts = 0;
                    while (attempts < 3) {
                        const server = this.servers[this.rrIndex % 3];
                        this.rrIndex++;
                        attempts++;
                        if (server.active) return server;
                    }
                    return null;
                }
                return this.servers[0];
            }

            showAlert(msg, type) {
                this.alertBox.innerText = msg;
                this.alertBox.className = `alert-${type}`;
                this.alertBox.style.opacity = 1;
                if (this.alertTimeout) clearTimeout(this.alertTimeout);
                this.alertTimeout = setTimeout(() => {
                    this.alertBox.style.opacity = 0;
                }, 3000);
            }

            updateSystemHealth() {
                if (this.algorithm === 'no-lb' && !this.servers[0].active) {
                    this.showAlert("CRITICAL: SINGLE POINT OF FAILURE", "danger");
                    document.getElementById('sys-status-text').innerText = "CRITICAL";
                    document.getElementById('sys-status-text').style.color = "var(--danger-color)";
                    document.getElementById('sys-indicator').style.backgroundColor = "var(--danger-color)";
                    return;
                }

                const activeCount = this.servers.filter(s => s.active).length;
                const healthPercent = Math.floor((activeCount / 3) * 100);
                const healthEl = document.getElementById('stat-health');
                healthEl.innerText = healthPercent + "%";

                if (activeCount === 3) {
                    healthEl.style.color = "var(--success-color)";
                    document.getElementById('sys-status-text').innerText = "ONLINE";
                    document.getElementById('sys-status-text').style.color = "var(--success-color)";
                    document.getElementById('sys-indicator').style.backgroundColor = "var(--success-color)";
                } else if (activeCount > 0) {
                    healthEl.style.color = "var(--warning-color)";
                    document.getElementById('sys-status-text').innerText = "DEGRADED";
                    document.getElementById('sys-status-text').style.color = "var(--warning-color)";
                    document.getElementById('sys-indicator').style.backgroundColor = "var(--warning-color)";
                } else {
                    healthEl.style.color = "var(--danger-color)";
                    document.getElementById('sys-status-text').innerText = "OFFLINE";
                    this.showAlert("SYSTEM OFFLINE", "danger");
                }
            }

            update() {
                const activePackets = this.packets.length;
                document.getElementById('stat-reqs').innerText = activePackets;

                let currentAvg = 20;
                if (this.latencySampleCount > 0) {
                    currentAvg = Math.floor(this.totalLatency / this.latencySampleCount);
                }

                const totalLoad = this.servers.reduce((acc, s) => acc + s.connections, 0);
                if (totalLoad > 10) currentAvg += (totalLoad * 5);

                if (this.algorithm === 'no-lb' && totalLoad > 4) {
                    currentAvg += 200;
                }

                const latEl = document.getElementById('stat-latency');
                latEl.innerText = currentAvg + 'ms';
                if (currentAvg > 100) {
                    latEl.className = 'stat-value latency-high';
                } else {
                    latEl.className = 'stat-value latency-low';
                }

                if (this.algorithm === 'no-lb') {
                    if (this.servers[0].connections > 5 && this.servers[0].active) {
                        this.servers[0].active = false;
                        this.servers[0].color = '#333';
                        this.showAlert("SERVER OVERLOAD - CRASHED!", "danger");
                        this.servers[0].connections = 0;
                    }
                }

                for (let i = this.packets.length - 1; i >= 0; i--) {
                    const p = this.packets[i];

                    if ((p.state === 'processing' || p.state === 'toServer') && p.assignedServer && !p.assignedServer.active) {
                        p.state = 'failed';
                        p.color = '#ff0055';
                        if (p.assignedServer) p.assignedServer.connections--;
                        p.assignedServer = null;
                        this.showAlert("CONNECTION LOST", "danger");
                    }

                    const dx = p.targetX - p.x;
                    const dy = p.targetY - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < p.speed) {
                        p.x = p.targetX;
                        p.y = p.targetY;

                        if (p.state === 'toLB') {
                            const target = this.getTargetServer();
                            if (target && target.active) {
                                p.assignedServer = target;
                                p.state = 'toServer';
                                p.targetX = target.x;
                                p.targetY = target.y + 30;
                                p.targetY += (Math.random() * 20 - 10);
                                target.connections++;
                            } else {
                                p.color = '#ff0055';
                                p.state = 'failed';
                                this.totalLatency += 1000;
                                this.latencySampleCount++;
                            }
                        } else if (p.state === 'toServer') {
                            p.state = 'processing';
                            p.processTime = 30;
                        } else if (p.state === 'processing') {
                            p.processTime--;
                            if (p.processTime <= 0) {
                                if (p.assignedServer) p.assignedServer.connections--;
                                p.state = 'done';
                                this.totalLatency += (Date.now() - p.birth);
                                if (this.latencySampleCount > 100) {
                                    this.latencySampleCount = 10;
                                    this.totalLatency = currentAvg * 10;
                                }
                                this.latencySampleCount++;
                                this.processedCount++;
                            }
                        }
                    } else {
                        p.x += (dx / dist) * p.speed;
                        p.y += (dy / dist) * p.speed;
                    }

                    if (p.state === 'failed') {
                        p.x += (Math.random() * 2 - 1);
                        p.y += (Math.random() * 2 - 1);
                        p.life = (p.life || 20) - 1;
                        if (p.life <= 0) this.packets.splice(i, 1);
                    } else if (p.state === 'done') {
                        this.packets.splice(i, 1);
                    }
                }

                if (Date.now() % 60 === 0) this.updateSystemHealth();
                this.updateSystemHealth();
            }

            draw() {
                this.ctx.fillStyle = '#1a1d26'; // New container bg match
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Use clearRect for transparent stack
                // But we want solid bg
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.strokeStyle = '#2c3540';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height / 2);
                this.ctx.lineTo(this.lb.x, this.lb.y + 30);
                this.servers.forEach(s => {
                    this.ctx.moveTo(this.lb.x + 60, this.lb.y + 30);
                    this.ctx.lineTo(s.x, s.y + 30);
                });
                this.ctx.stroke();

                this.ctx.strokeStyle = '#45a29e';
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(20, this.canvas.height / 2 - 150, 60, 300);
                this.ctx.fillStyle = '#66fcf1';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText("CLIENTS", 25, this.canvas.height / 2 - 160);
                this.ctx.setLineDash([]);

                if (this.algorithm !== 'no-lb') {
                    this.ctx.fillStyle = '#1f2833';
                    this.ctx.strokeStyle = '#66fcf1';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    const lbX = this.lb.x + 30;
                    const lbY = this.lb.y + 30;
                    this.ctx.moveTo(lbX - 20, lbY - 20);
                    this.ctx.lineTo(lbX + 20, lbY - 20);
                    this.ctx.lineTo(lbX + 20, lbY);
                    this.ctx.lineTo(lbX, lbY + 25);
                    this.ctx.lineTo(lbX - 20, lbY);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText("LB", lbX - 8, lbY + 5);
                }

                this.servers.forEach(s => {
                    this.ctx.fillStyle = s.active ? '#1f2833' : '#222';
                    this.ctx.strokeStyle = s.active ? s.color : '#555';

                    if (s.active && s.connections > 5) {
                        const pulse = Math.abs(Math.sin(Date.now() / 100)) * 10;
                        this.ctx.shadowBlur = 15 + pulse;
                        this.ctx.shadowColor = '#ff0055';
                        this.ctx.strokeStyle = '#ff0055';
                    } else {
                        this.ctx.shadowBlur = 0;
                    }

                    this.ctx.beginPath();
                    this.ctx.roundRect(s.x, s.y, 60, 60, 5);
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;

                    this.ctx.fillStyle = s.active ? '#fff' : '#555';
                    this.ctx.font = '12px Courier New';
                    this.ctx.fillText(`SRV ${s.id}`, s.x + 10, s.y + 20);
                    if (s.active) {
                        this.ctx.fillText(`L:${s.connections}`, s.x + 10, s.y + 40);
                    } else {
                        this.ctx.fillStyle = '#ff0055';
                        this.ctx.fillText(`DOWN`, s.x + 10, s.y + 40);
                    }

                    this.ctx.beginPath();
                    this.ctx.arc(s.x + 50, s.y + 10, 4, 0, Math.PI * 2);
                    this.ctx.fillStyle = s.active ? (s.connections > 5 ? '#ff0055' : '#00ff66') : '#555';
                    this.ctx.fill();
                });

                this.packets.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 5;
                    this.ctx.shadowColor = p.color;
                });
                this.ctx.shadowBlur = 0;

                requestAnimationFrame(() => {
                    this.update();
                    this.draw();
                });
            }

            loop() {
                this.draw();
            }
        }

        const sim = new Simulation();

        // LATENCY GRAPH DEMO (INTERACTIVE)
        class LatencyGraph {
            constructor() {
                this.canvas = document.getElementById('latencyCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.pointsRR = [];
                this.pointsNoLB = [];
                this.events = []; // Metadata for tooltips
                this.mouseX = -1;
                this.mouseY = -1;

                this.initData();
                this.resize();

                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouseX = -1;
                    this.draw();
                });
            }

            initData() {
                // Determine width based on initial size (approx)
                const w = this.canvas.offsetWidth || 800; // Fallback
                const count = Math.floor(w / 10);

                this.pointsRR = [];
                this.pointsNoLB = [];
                this.events = [];

                for (let i = 0; i <= count; i++) {
                    const baseRR = 20 + Math.sin(i * 0.5) * 5 + Math.random() * 2;
                    this.pointsRR.push(baseRR);

                    let baseNoLB = 50 + Math.random() * 20;
                    let event = null;

                    // Spike 1: "Viral Content"
                    if (i > 10 && i < 15) {
                        baseNoLB += 150;
                        event = "‚ö†Ô∏è Traffic Spike (Viral Post)";
                    }
                    // Dip: "Cache Miss"
                    else if (i > 25 && i < 35) {
                        baseNoLB += 100;
                        event = "‚ö†Ô∏è Database Lock / Slow Query";
                    }
                    // Crash: "Overload"
                    else if (i > 45 && i < 50) {
                        baseNoLB += 250;
                        event = "üî• CRITICAL: Server Overload (503)";
                    } else {
                        event = "‚úÖ Normal Operation";
                    }

                    this.pointsNoLB.push(baseNoLB);
                    this.events.push(event);
                }
            }

            resize() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                // Re-init data if width changes significantly to fit screen
                // Simple approach: re-init to fill new width
                this.initData();
                this.draw();
            }

            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseX = e.clientX - rect.left;
                this.mouseY = e.clientY - rect.top;
                this.draw();
            }

            draw() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const ctx = this.ctx;

                // Clear
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);

                // Grid
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i < w; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, h); ctx.stroke(); }
                for (let i = 0; i < h; i += 50) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke(); }

                const scaleY = (h - 40) / 350; // Max likely latency 350ms

                // Line Helper
                const drawLine = (data, color, width, isHovered) => {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = isHovered ? width + 2 : width;
                    if (isHovered) ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    data.forEach((val, i) => {
                        const x = i * 10;
                        const y = h - 20 - (val * scaleY);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                };

                let activeLine = null;
                let activeIndex = -1;

                if (this.mouseX >= 0) {
                    activeIndex = Math.floor(this.mouseX / 10);
                    if (activeIndex >= 0 && activeIndex < this.pointsNoLB.length) {
                        const yNoLB = h - 20 - (this.pointsNoLB[activeIndex] * scaleY);
                        const yRR = h - 20 - (this.pointsRR[activeIndex] * scaleY);
                        const distNoLB = Math.abs(this.mouseY - yNoLB);
                        const distRR = Math.abs(this.mouseY - yRR);
                        const threshold = 50;

                        if (distNoLB < threshold && distNoLB < distRR) activeLine = 'nolb';
                        else if (distRR < threshold) activeLine = 'rr';
                    }
                }

                drawLine(this.pointsNoLB, '#ff0055', 3, activeLine === 'nolb');
                drawLine(this.pointsRR, '#00ff66', 3, activeLine === 'rr');

                if (activeLine && activeIndex >= 0) {
                    const x = activeIndex * 10;
                    const valNoLB = Math.floor(this.pointsNoLB[activeIndex]);
                    const valRR = Math.floor(this.pointsRR[activeIndex]);
                    const eventText = this.events[activeIndex];

                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 1;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const tooltipW = 220;
                    const tooltipH = 80;
                    let tooltipX = x + 15;
                    let tooltipY = this.mouseY;

                    if (tooltipX + tooltipW > w) tooltipX = x - tooltipW - 15;
                    if (tooltipY + tooltipH > h) tooltipY = h - tooltipH - 10;
                    if (tooltipY < 0) tooltipY = 10;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                    ctx.strokeStyle = activeLine === 'nolb' ? '#ff0055' : '#00ff66';
                    ctx.lineWidth = 2;
                    ctx.fillRect(tooltipX, tooltipY, tooltipW, tooltipH);
                    ctx.strokeRect(tooltipX, tooltipY, tooltipW, tooltipH);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Time: T+${activeIndex}s`, tooltipX + 10, tooltipY + 20);

                    if (activeLine === 'nolb') {
                        ctx.fillStyle = '#ff0055';
                        ctx.fillText(`No LB Latency: ${valNoLB}ms`, tooltipX + 10, tooltipY + 40);
                        ctx.fillStyle = '#ffcc00';
                        ctx.font = '11px Courier New';
                        ctx.fillText(`${eventText}`, tooltipX + 10, tooltipY + 65);
                    } else {
                        ctx.fillStyle = '#00ff66';
                        ctx.fillText(`Round Robin: ${valRR}ms`, tooltipX + 10, tooltipY + 40);
                        ctx.fillStyle = '#ffcc00';
                        ctx.font = '11px Courier New';
                        ctx.fillText("‚úÖ Optimal Distribution", tooltipX + 10, tooltipY + 65);
                    }
                }

                ctx.fillStyle = '#888';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText("Latency (ms)", 10, 20);
                ctx.textAlign = 'right';
                ctx.fillText("Time ->", w - 10, h - 10);
            }
        }

        // Init Graph
        new LatencyGraph();
    </script>
</body>

</html>
